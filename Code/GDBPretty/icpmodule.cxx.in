#include "Python.h"
#include "structmember.h"

#include <QtCore/QByteArray>
#include <QtCore/QProcess>
#include <QLocalServer>
#include <QLocalSocket>

#include <cstring>
#include <iostream>
#include <sstream>

#include "QImageReceiver.h"

//! This is used for spawning the gui process.
static QProcess * process = new QProcess();
static QLocalServer * server = new QLocalServer();
static QLocalSocket * socket;


static PyObject * _cleanup_QProcess( PyObject * self, PyObject * args )
{
  if( process->state() == QProcess::Running )
    process->kill();
  delete server;
  Py_INCREF( Py_None );
  return Py_None;
}

static const char icpGuiBuildLocation[] = "@ICPGUI_BUILD_LOCATION@";
static const char icpGuiInstallLocation[] = "@ICPGUI_INSTALL_LOCATION@";

/** Our gdb pretty printer class.  An instantiation of this struct is like a C++
 * class this*, but in python it is traditionally call self*.
 */
typedef struct
{
  PyObject_HEAD
  PyObject * val; //  the gdb.Value to be 'printed'
} ICPPrinter;

/** This is equivalent in C++ to the constructor for ICPPrinter. */
static PyObject *
ICPPrinter_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
{
  ICPPrinter *self;

  self = (ICPPrinter *)type->tp_alloc(type, 0);
  if ( self != NULL )
  {
  PyObject * gdbModule = PyImport_ImportModule( "gdb" );
  if( gdbModule == NULL )
    return NULL;
  PyObject * valueClass = PyObject_GetAttrString( gdbModule, "Value" );
  Py_DECREF( gdbModule );
  if( valueClass == NULL )
    return NULL;
  PyObject * valueArgs = Py_BuildValue( "(i)", 0 );
  self->val = PyEval_CallObject( valueClass, valueArgs );
  Py_DECREF( valueArgs );
  Py_DECREF( valueClass );
  if( self->val == NULL )
    {
    Py_DECREF( self );
    return NULL;
    }
  }

  return (PyObject *)self;
}

/** This is equivalent in C++ to the destructor for ICPPrinter. */
static void
ICPPrinter_dealloc( ICPPrinter * self )
{
  Py_XDECREF( self->val );
  self->ob_type->tp_free((PyObject*)self);
}


/** This defines the python constructor that would normally be defined with
 * __init__(self) in python. */
static int
ICPPrinter_init( ICPPrinter * self, PyObject * args, PyObject * kwds )
{
  PyObject * val = NULL;
  PyObject * tmp;

  if ( !PyArg_ParseTuple( args, "O", &val ))
    return -1;

  if (val)
    {
    tmp = self->val;
    Py_INCREF(val);
    self->val = val;
    Py_XDECREF(tmp);
    }

  return 0;
}

static PyObject * ICPPrinter_to_string( ICPPrinter * self )
{
  QString program = icpGuiBuildLocation;
  if( process->state() == QProcess::NotRunning )
    {
    // @todo These two can eventually be commented out for Windows compatibility.
    process->setStandardOutputFile( "/dev/stdout", QIODevice::Append );
    process->setStandardOutputFile( "/dev/stderr", QIODevice::Append );
    process->start( program );
    if( !server->isListening() )
      {
      QString pid;
#ifdef Q_OS_WIN
      // @todo this needs to be tested that it returns the same as
      // QCoreApplication::applicationPid() used int QImageReceiver.
      pid.setNum( process->pid()->dwProcessId );
#else
      pid.setNum( process->pid() );
#endif
      if( !server->listen( QString( "icpPythonModule" ) + pid ))
        {
        PyErr_SetString( PyExc_OSError, server->errorString().toUtf8().data() );
        return NULL;
        }
      }
    if( !process->waitForStarted( 3000 ) )
      {
      PyErr_SetString( PyExc_OSError, "Could not start the icpGui." );
      return NULL;
      }
    if( !server->waitForNewConnection( 3000 ) )
      {
      PyErr_SetString( PyExc_OSError, "icpGui did not connect to local server." );
      return NULL;
      }
    socket = server->nextPendingConnection();
    }

  PyObject * type = PyObject_GetAttrString( self->val, "type" );
  if( type == NULL )
    return NULL;
  PyObject * dimension_o = PyObject_CallMethod( type, "template_argument", "i", 1 );
  Py_DECREF( type );
  long dimension;
  if( dimension_o == NULL )
    {
    PyObject * errType;
    PyObject * errValue;
    PyObject * errTraceback;
    PyErr_Fetch( &errType, &errValue, &errTraceback );
    if( errValue != NULL &&
      PyString_Check( errValue ) )
      {
      char * dimension_c = PyString_AS_STRING( errValue );
      // Counting on the location of the dimension not changing in the error
      // string.  Right now it is "No type named 3u."
      std::string dimension_s( 1, dimension_c[14] );
      std::istringstream istr( dimension_s );
      istr >> dimension;
      }
    else
      {
      PyErr_Restore( errType, errValue, errTraceback );
      return NULL;
      }
    }
  else
    {
    dimension = PyInt_AsLong( dimension_o );
    Py_DECREF( dimension_o );
    }

  // Send note that the image is on its way.
  QByteArray ba;
  int content;
  int* data_p;
  size_t contentLength;
  content = QImageReceiver::InitializationString;
  ba.resize( sizeof( int ) );
  data_p = reinterpret_cast< int* >( ba.data() );
  *data_p = content;
  ba.append( "An image is on its way (take cover!)" );
  socket->write( ba );
  if( !socket->waitForBytesWritten( 3000 ) )
    {
    PyErr_SetString( PyExc_RuntimeError, "Failed to write to socket." );
    return NULL;
    }

  // Common vars.
  PyObject * key;
  long i = 0;
  PyObject * longComponent_o;
  long longComponent;
  const char * longComponent_c = reinterpret_cast< const char * >( &longComponent );

  // Get the size of the buffered region.
  key = PyString_FromString( "m_BufferedRegion" );
  PyObject * bufferedRegion = PyObject_GetItem( self->val, key );
  Py_DECREF( key );
  if( bufferedRegion == NULL )
    return NULL;
  key = PyString_FromString( "m_Size" );
  PyObject * size = PyObject_GetItem( bufferedRegion, key );
  Py_DECREF( bufferedRegion );
  PyObject * size_size = PyObject_GetItem( size, key );
  Py_DECREF( size );
  Py_DECREF( key );
  if( size_size == NULL )
    return NULL;
  long size_a[3] = {1, 1, 1};
  for( i = 0; i < dimension; ++i )
    {
    key = PyInt_FromLong( i );
    longComponent_o = PyObject_GetItem( size_size, key );
    size_a[i] = PyInt_AsLong( longComponent_o );
    Py_DECREF( longComponent_o );
    Py_DECREF( key );
    }
  content = QImageReceiver::ImageSize;
  contentLength = sizeof( int ) + 3 * sizeof( long );
  ba.resize( contentLength );
  data_p = reinterpret_cast< int* >( ba.data() );
  *data_p = content;
  memcpy( ba.data() + sizeof( int ), &size_a, contentLength );
  socket->write( ba );
  if( !socket->waitForBytesWritten( 3000 ) )
    {
    PyErr_SetString( PyExc_RuntimeError, "Failed to write to socket." );
    return NULL;
    }

  //PyObject_Print( size_size, stdout, Py_PRINT_RAW );

  return PyString_FromString( "\nwhat a lovely image you have" );
}

/** The python class members for ICPPrinter. */
static PyMethodDef ICPPrinter_methods[] = {
    {"to_string", (PyCFunction)ICPPrinter_to_string, METH_NOARGS,
     "Prints information about the image and sends it to the gui."
    },
    {NULL}  /* Sentinel */
};

static PyMemberDef ICPPrinter_members[] = {
    {"val", T_OBJECT_EX, offsetof(ICPPrinter, val), 0,
     "gdb.Value to print."},
    {NULL}  /* Sentinel */
};

/** The PyTypeObject for ICPPrinter.  This defines how ICPPrinter behaves in
 * python. */
static PyTypeObject ICPPrinterType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "icp.ICPPrinter",             /*tp_name*/
    sizeof( ICPPrinter ),             /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)ICPPrinter_dealloc, /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
    "GDB Pretty Printer that creates a Qt/VTK gui displaying images passed to it.",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    0,                         /* tp_iter */
    0,                         /* tp_iternext */
    ICPPrinter_methods,             /* tp_methods */
    ICPPrinter_members,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)ICPPrinter_init,      /* tp_init */
    0,                         /* tp_alloc */
    ICPPrinter_new,                 /* tp_new */
};

/** Create the lookup_function Python function.  This is a function associated
 * with the module expected by my version of gdb.pretty used for by register
 * function.
 *
 * The PyObject* is return, or NULL if a failure occurred.
 */
static PyObject * lookup_function( PyObject * icpPrinter )
{
  PyObject * npArrayModule = PyImport_ImportModule( "itk.v3.numpy.array" );
  if( npArrayModule == NULL )
    return NULL;
  PyObject * lookupFunctionClass = PyObject_GetAttrString( npArrayModule, "RELookupFunctionTagNumpyType" );
  if( lookupFunctionClass == NULL )
    {
    Py_DECREF( npArrayModule );
    return NULL;
    }

  PyObject * prettyPrintersDict = PyDict_New();
  PyObject * re_dict = PyObject_GetAttrString( npArrayModule, "re_dict" );
  Py_DECREF( npArrayModule );
  if( re_dict == NULL )
    {
    Py_DECREF( prettyPrintersDict );
    Py_DECREF( re_dict );
    return NULL;
    }
  PyObject * reImage = PyDict_GetItemString( re_dict, "Image" );
  Py_DECREF( re_dict );
  if( reImage == NULL )
    {
    Py_DECREF( prettyPrintersDict );
    return NULL;
    }
  if( PyDict_SetItem( prettyPrintersDict, reImage, icpPrinter ) == -1 )
    {
    Py_DECREF( prettyPrintersDict );
    return NULL;
    }

  PyObject * prettyPrintersDictArgs = Py_BuildValue( "(O)", prettyPrintersDict );
  PyObject * lookupFunction = PyEval_CallObject( lookupFunctionClass,  prettyPrintersDictArgs );
  Py_DECREF( prettyPrintersDict );
  Py_DECREF( prettyPrintersDictArgs );
  Py_DECREF( lookupFunctionClass );
  if( lookupFunction == NULL )
    return NULL;

  return lookupFunction;
}

extern "C"
{

static PyObject * icpError;

static PyMethodDef icpMethods[] =
{
  {"_cleanup_QProcess", _cleanup_QProcess, METH_NOARGS,
    "Internal method for cleanup of the module." },
  {NULL, NULL, 0, NULL} /* Sentinel */
};

PyMODINIT_FUNC  initicp(void)
{
  // The module object
  PyObject * m;
  m = Py_InitModule3( "icp", icpMethods, "Use itkCompareProject to examine images while with the gdb's pretty printers." );
  if( m == NULL )
    return;

  // Create a module specific exception.  This will be used when encountering
  // itk::Exception's, etc.
  icpError = PyErr_NewException(const_cast<char*>("icp.error"), NULL, NULL);
  Py_INCREF(icpError);
  PyModule_AddObject( m, "error", icpError );

  // Create the ICPPrinter gdb pretty printer.
  if( PyType_Ready( &ICPPrinterType ) < 0 )
    return;
  Py_INCREF( &ICPPrinterType );
  PyModule_AddObject( m, "ICPPrinter", (PyObject *)&ICPPrinterType );

  // Create lookup_function.
  PyObject * lookupFunction = lookup_function( (PyObject *)&ICPPrinterType );
  if( lookupFunction == NULL )
    return;
  PyModule_AddObject( m, "lookup_function", lookupFunction );

  // We use the atexit module here because, at least at this time, it appears
  // gdb cannot call Py_Finalize without
  // "Fatal Python error: auto-releasing thread-state, but no thread-state for
  // this thread".
  PyObject * atexit = PyImport_ImportModule( "atexit" );
  if( atexit == NULL )
    return;
  PyObject * register_m = PyObject_GetAttrString( atexit, "register" );
  Py_DECREF( atexit );
  if( register_m == NULL )
    return;
  PyObject * _cleanup_QProcess_m = PyObject_GetAttrString( m, "_cleanup_QProcess" );
  if( _cleanup_QProcess_m == NULL )
    return;
  PyObject * registerArgs = Py_BuildValue( "(O)", _cleanup_QProcess_m );
  PyObject * registerReturn = PyEval_CallObject( register_m, registerArgs );
  Py_DECREF( registerArgs );
  Py_DECREF( register_m );
  if( registerReturn == NULL )
    return;
  Py_DECREF( registerReturn );
}
} // end extern "C"
