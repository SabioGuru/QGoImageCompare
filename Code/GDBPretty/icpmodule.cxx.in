#include "Python.h"
#include "structmember.h"

#include <QtCore/QProcess>

#include <iostream>

//! This is used for spawning the gui process.
static QProcess * process = new QProcess();

static PyObject * _cleanup_QProcess( PyObject * self, PyObject * args )
{
  if( process->state() == QProcess::Running )
    process->kill();
  process->waitForFinished();
  delete process;
  Py_INCREF( Py_None );
  return Py_None;
}

static const char icpGuiBuildLocation[] = "@ICPGUI_BUILD_LOCATION@";
static const char icpGuiInstallLocation[] = "@ICPGUI_INSTALL_LOCATION@";

/** Our gdb pretty printer class.  An instantiation of this struct is like a C++
 * class this*, but in python it is traditionally call self*.
 */
typedef struct
{
  PyObject_HEAD
  PyObject * val; //  the gdb.Value to be 'printed'
} ICPPrinter;

/** This is equivalent in C++ to the constructor for ICPPrinter. */
static PyObject *
ICPPrinter_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
{
  ICPPrinter *self;

  self = (ICPPrinter *)type->tp_alloc(type, 0);
  if ( self != NULL )
  {
  PyObject * gdbModule = PyImport_ImportModule( "gdb" );
  if( gdbModule == NULL )
    return NULL;
  PyObject * valueClass = PyObject_GetAttrString( gdbModule, "Value" );
  Py_DECREF( gdbModule );
  if( valueClass == NULL )
    return NULL;
  PyObject * valueArgs = Py_BuildValue( "(i)", 0 );
  self->val = PyEval_CallObject( valueClass, valueArgs );
  Py_DECREF( valueArgs );
  Py_DECREF( valueClass );
  if( self->val == NULL )
    {
    Py_DECREF( self );
    return NULL;
    }
  }

  return (PyObject *)self;
}

/** This is equivalent in C++ to the destructor for ICPPrinter. */
static void
ICPPrinter_dealloc( ICPPrinter * self )
{
  Py_XDECREF( self->val );
  self->ob_type->tp_free((PyObject*)self);
}


/** This defines the python constructor that would normally be defined with
 * __init__(self) in python. */
static int
ICPPrinter_init( ICPPrinter * self, PyObject * args, PyObject * kwds )
{
  PyObject * val = NULL;
  PyObject * tmp;

  if ( !PyArg_ParseTuple( args, "O", &val ))
    return -1;

  if (val)
    {
    tmp = self->val;
    Py_INCREF(val);
    self->val = val;
    Py_XDECREF(tmp);
    }

  return 0;
}

static PyObject * ICPPrinter_to_string( ICPPrinter * self )
{
  QString program = icpGuiBuildLocation;
  if( process->state() == QProcess::NotRunning )
    {
    process->start( program );
    if( !process->waitForStarted() )
      {
      PyErr_SetString( PyExc_OSError, "Could not start the icpGui." );
      return NULL;
      }
    }
  return PyString_FromString( "what a lovely image you have" );
}

/** The python class members for ICPPrinter. */
static PyMethodDef ICPPrinter_methods[] = {
    {"to_string", (PyCFunction)ICPPrinter_to_string, METH_NOARGS,
     "Prints information about the image and sends it to the gui."
    },
    {NULL}  /* Sentinel */
};

static PyMemberDef ICPPrinter_members[] = {
    {"val", T_OBJECT_EX, offsetof(ICPPrinter, val), 0,
     "gdb.Value to print."},
    {NULL}  /* Sentinel */
};

/** The PyTypeObject for ICPPrinter.  This defines how ICPPrinter behaves in
 * python. */
static PyTypeObject ICPPrinterType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "icp.ICPPrinter",             /*tp_name*/
    sizeof( ICPPrinter ),             /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)ICPPrinter_dealloc, /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
    "GDB Pretty Printer that creates a Qt/VTK gui displaying images passed to it.",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    0,                         /* tp_iter */
    0,                         /* tp_iternext */
    ICPPrinter_methods,             /* tp_methods */
    ICPPrinter_members,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)ICPPrinter_init,      /* tp_init */
    0,                         /* tp_alloc */
    ICPPrinter_new,                 /* tp_new */
};

/** Create the lookup_function Python function.  This is a function associated
 * with the module expected by my version of gdb.pretty used for by register
 * function.
 *
 * The PyObject* is return, or NULL if a failure occurred.
 */
static PyObject * lookup_function( PyObject * icpPrinter )
{
  PyObject * npArrayModule = PyImport_ImportModule( "itk.v3.numpy.array" );
  if( npArrayModule == NULL )
    return NULL;
  PyObject * lookupFunctionClass = PyObject_GetAttrString( npArrayModule, "RELookupFunctionTagNumpyType" );
  if( lookupFunctionClass == NULL )
    {
    Py_DECREF( npArrayModule );
    return NULL;
    }

  PyObject * prettyPrintersDict = PyDict_New();
  PyObject * re_dict = PyObject_GetAttrString( npArrayModule, "re_dict" );
  Py_DECREF( npArrayModule );
  if( re_dict == NULL )
    {
    Py_DECREF( prettyPrintersDict );
    Py_DECREF( re_dict );
    return NULL;
    }
  PyObject * reImage = PyDict_GetItemString( re_dict, "Image" );
  Py_DECREF( re_dict );
  if( reImage == NULL )
    {
    Py_DECREF( prettyPrintersDict );
    return NULL;
    }
  if( PyDict_SetItem( prettyPrintersDict, reImage, icpPrinter ) == -1 )
    {
    Py_DECREF( prettyPrintersDict );
    return NULL;
    }

  PyObject * prettyPrintersDictArgs = Py_BuildValue( "(O)", prettyPrintersDict );
  PyObject * lookupFunction = PyEval_CallObject( lookupFunctionClass,  prettyPrintersDictArgs );
  Py_DECREF( prettyPrintersDict );
  Py_DECREF( prettyPrintersDictArgs );
  Py_DECREF( lookupFunctionClass );
  if( lookupFunction == NULL )
    return NULL;

  return lookupFunction;
}

extern "C"
{

static PyObject * icpError;

static PyMethodDef icpMethods[] =
{
  {"_cleanup_QProcess", _cleanup_QProcess, METH_NOARGS,
    "Internal method for cleanup of the module." },
  {NULL, NULL, 0, NULL} /* Sentinel */
};

PyMODINIT_FUNC  initicp(void)
{
  // The module object
  PyObject * m;
  m = Py_InitModule3( "icp", icpMethods, "Use itkCompareProject to examine images while with the gdb's pretty printers." );
  if( m == NULL )
    return;

  // Create a module specific exception.  This will be used when encountering
  // itk::Exception's, etc.
  icpError = PyErr_NewException(const_cast<char*>("icp.error"), NULL, NULL);
  Py_INCREF(icpError);
  PyModule_AddObject( m, "error", icpError );

  // Create the ICPPrinter gdb pretty printer.
  if( PyType_Ready( &ICPPrinterType ) < 0 )
    return;
  Py_INCREF( &ICPPrinterType );
  PyModule_AddObject( m, "ICPPrinter", (PyObject *)&ICPPrinterType );

  // Create lookup_function.
  PyObject * lookupFunction = lookup_function( (PyObject *)&ICPPrinterType );
  if( lookupFunction == NULL )
    return;
  PyModule_AddObject( m, "lookup_function", lookupFunction );

  // We use the atexit module here because, at least at this time, it appears
  // gdb cannot call Py_Finalize without
  // "Fatal Python error: auto-releasing thread-state, but no thread-state for
  // this thread".
  PyObject * atexit = PyImport_ImportModule( "atexit" );
  if( atexit == NULL )
    return;
  PyObject * register_m = PyObject_GetAttrString( atexit, "register" );
  Py_DECREF( atexit );
  if( register_m == NULL )
    return;
  PyObject * _cleanup_QProcess_m = PyObject_GetAttrString( m, "_cleanup_QProcess" );
  if( _cleanup_QProcess_m == NULL )
    return;
  PyObject * registerArgs = Py_BuildValue( "(O)", _cleanup_QProcess_m );
  PyObject * registerReturn = PyEval_CallObject( register_m, registerArgs );
  Py_DECREF( registerArgs );
  Py_DECREF( register_m );
  if( registerReturn == NULL )
    return;
}
} // end extern "C"
